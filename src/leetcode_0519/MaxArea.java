package leetcode_0519;

import java.util.Arrays;

public class MaxArea {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] height = {4,3,2,1,4};
		System.out.println(maxArea(height));
	}
	public static int maxArea(int[] height) {
        int area =0;
        int len = height.length;
        int left =0,right = len-1;
        while(left<right) {
        	area = Math.max(area, height[left]>height[right] ? height[right--]*(right - left+1) : height[left++]*(right-left+1));
        }
        return area;
    }
	public static int threeSumClosest(int[] nums, int target) {
		int len = nums.length;
        int[] ans = new int[len];
        int[] temp = new int[len];
        for(int i=0;i<len;i++) {
        	ans[i] = target-nums[i];
        	temp[i] = Math.abs(ans[i]);
        }
        Arrays.sort(temp);
        return 0;
        
    }
	 public int threeSumClosest1(int[] nums, int target) {
	        Arrays.sort(nums);
	        int n = nums.length;
	        int best = 10000000;

	        // 枚举 a
	        for (int i = 0; i < n; ++i) {
	            // 保证和上一次枚举的元素不相等
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	            // 使用双指针枚举 b 和 c
	            int j = i + 1, k = n - 1;
	            while (j < k) {
	                int sum = nums[i] + nums[j] + nums[k];
	                // 如果和为 target 直接返回答案
	                if (sum == target) {
	                    return target;
	                }
	                // 根据差值的绝对值来更新答案
	                if (Math.abs(sum - target) < Math.abs(best - target)) {
	                    best = sum;
	                }
	                if (sum > target) {
	                    // 如果和大于 target，移动 c 对应的指针
	                    int k0 = k - 1;
	                    // 移动到下一个不相等的元素
	                    while (j < k0 && nums[k0] == nums[k]) {
	                        --k0;
	                    }
	                    k = k0;
	                } else {
	                    // 如果和小于 target，移动 b 对应的指针
	                    int j0 = j + 1;
	                    // 移动到下一个不相等的元素
	                    while (j0 < k && nums[j0] == nums[j]) {
	                        ++j0;
	                    }
	                    j = j0;
	                }
	            }
	        }
	        return best;
	    }

}
